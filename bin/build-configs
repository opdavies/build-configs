#!/usr/bin/env php
<?php

declare(strict_types=1);

require __DIR__.'/../vendor/autoload.php';

use Illuminate\Support\{Arr, Collection};
use OliverDaviesLtd\BuildConfigs\Enum\{Language, WebServer};
use OliverDaviesLtd\BuildConfigs\Validator\ConfigurationValidator;
use Silly\Application;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Validator\ConstraintViolationInterface;
use Symfony\Component\Yaml\Yaml;
use Twig\Environment;
use Twig\Loader\FilesystemLoader;

$app = new Application();

$app->command(
    'generate-build-file [-p|--project-name=] [-t|--type=]',
    function(
        string $projectName,
        string $type,
    ): void {
        $projectName = str_replace('.', '-', $projectName);

        // TODO: validate the project type.
        $output = <<<EOF
            name: $projectName
            type: $type
            EOF;

        file_put_contents('build.yaml', $output);
    }
)->descriptions('Generate a new build.yaml file.', [
    '--project-name' => 'The name of the project.',
    '--type' => 'The project type.',
]);;

$app->command(
    'run [-c|--config-file=] [-o|--output-dir=]',
    function (
        SymfonyStyle $io,
        string $configFile = 'build.yaml',
        string $outputDir = '.',
    ): void {
        $configurationData = array_merge(
            Yaml::parseFile(__DIR__ . '/../resources/build.defaults.yaml'),
            Yaml::parseFile($configFile),
        );

        $violations = (new ConfigurationValidator())->validate($configurationData);

        if (0 < $violations->count()) {
            $io->error('Configuration is invalid.');

            $io->listing(
                collect($violations)
                    ->map(fn (ConstraintViolationInterface $v) => "{$v->getInvalidValue()} - {$v->getMessage()}")
                    ->toArray()
            );

            return;
        }

        if (isset($configurationData['docker-compose'])) {
            $configurationData['dockerCompose'] = $configurationData['docker-compose'];
            $configurationData['docker-compose'] = null;
        }

        $io->info("Building configuration for {$configurationData['name']}.");

        $filesToGenerate = collect([
            ['common/.dockerignore', '.dockerignore'],
            ['common/.hadolint.yaml', '.hadolint.yaml'],
            ['env.example', '.env.example'],
        ]);

        $extraDatabases = Arr::get($configurationData, 'database.extra_databases', []);
        if (count($extraDatabases) > 0) {
            $filesystem = new Filesystem();
            $filesystem->mkdir("{$outputDir}/tools/docker/images/database/root/docker-entrypoint-initdb.d");
            $filesToGenerate->push(['extra-databases.sql', 'tools/docker/images/database/root/docker-entrypoint-initdb.d/extra-databases.sql']);
        }

        if (false !== Arr::get($configurationData, "justfile", true)) {
            $filesToGenerate->push(['justfile', 'justfile']);
        }

        if (isset($configurationData['dockerCompose']) && $configurationData['dockerCompose'] !== null) {
            $filesToGenerate->push(['docker-compose.yaml', 'docker-compose.yaml']);
        }

        if (isPhp(Arr::get($configurationData, 'language'))) {
            $filesToGenerate->push(['php/Dockerfile', 'Dockerfile']);
            $filesToGenerate->push(['php/phpcs.xml', 'phpcs.xml.dist']);
            $filesToGenerate->push(['php/phpstan.neon', 'phpstan.neon.dist']);
            $filesToGenerate->push(['php/phpunit.xml', 'phpunit.xml.dist']);
            $filesToGenerate->push(['php/docker-entrypoint-php', 'tools/docker/images/php/root/usr/local/bin/docker-entrypoint-php']);
        }

        if (isNode(Arr::get($configurationData, 'language'))) {
            $filesToGenerate->push(['node/.yarnrc', '.yarnrc']);
            $filesToGenerate->push(['node/Dockerfile', 'Dockerfile']);
        }

        if (isCaddy(Arr::get($configurationData, 'web.type'))) {
            $filesToGenerate->push(['web/caddy/Caddyfile', 'tools/docker/images/web/root/etc/caddy/Caddyfile']);
        }

        if (isNginx(Arr::get($configurationData, 'web.type'))) {
            $filesToGenerate->push(['web/nginx/default.conf', 'tools/docker/images/web/root/etc/nginx/conf.d/default.conf']);
        }

        if ('drupal-project' === Arr::get($configurationData, 'type')) {
            // Add a Drupal version of phpunit.xml.dist.
            $filesToGenerate->push(['drupal-project/phpunit.xml.dist', 'phpunit.xml.dist']);
        }

        $configurationData['managedText'] = 'Do not edit this file. It is automatically generated by \'build-configs\'.';

        generateFiles(
            configurationData: $configurationData,
            filesToGenerate: $filesToGenerate,
            outputDir: $outputDir,
        );
    }
)->descriptions('Generate project-specific configuration files.', [
    '--config-file' => 'The path to the project\'s build.yaml file',
    '--output-dir' => 'The directory to create files in',
]);

$app->run();

/**
 * @param array<string, string> $configurationData
 */
function generateFiles(
    Collection $filesToGenerate,
    string $outputDir,
    array $configurationData,
): void
{
    $filesystem = new Filesystem();
    $twig = new Environment(new FilesystemLoader([__DIR__ . '/../templates']));

    if (isPhp(Arr::get($configurationData, 'language'))) {
        $filesystem->mkdir("{$outputDir}/tools/docker/images/php/root/usr/local/bin");
    }

    if (isCaddy(Arr::get($configurationData, 'web.type'))) {
        $filesystem->mkdir("{$outputDir}/tools/docker/images/web/root/etc/caddy");
    } elseif (isNginx(Arr::get($configurationData, 'web.type'))) {
        $filesystem->mkdir("{$outputDir}/tools/docker/images/web/root/etc/nginx/conf.d");
    }

    $filesToGenerate->map(function(array $filenames) use ($outputDir): array {
        $filenames[0] = "{$filenames[0]}.twig";
        $filenames[1] = "{$outputDir}/${filenames[1]}";

        return $filenames;
    })->each(function(array $filenames) use ($configurationData, $filesystem, $twig): void {
        $filesystem->dumpFile($filenames[1], $twig->render($filenames[0], $configurationData));
    });

    // If the Docker entrypoint file is generated, ensure it is executable.
    if ($filesystem->exists("{$outputDir}/tools/docker/images/php/root/usr/local/bin/docker-entrypoint-php")) {
        $filesystem->chmod("{$outputDir}/tools/docker/images/php/root/usr/local/bin/docker-entrypoint-php", 0755);
    }
}

function isCaddy(?string $webServer): bool
{
    if (is_null($webServer)) {
        return false;
    }

    return strtoupper($webServer) === WebServer::CADDY->name;
}

function isNginx(?string $webServer): bool
{
    if (is_null($webServer)) {
        return false;
    }

    return strtoupper($webServer) === WebServer::NGINX->name;
}

function isNode(?string $language): bool
{
    if (is_null($language)) {
        return false;
    }

    return strtoupper($language) === Language::NODE->name;
}

function isPhp(?string $language): bool
{
    if (is_null($language)) {
        return false;
    }

    return strtoupper($language) === Language::PHP->name;
}
