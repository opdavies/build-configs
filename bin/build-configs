#!/usr/bin/env php
<?php

declare(strict_types=1);

require __DIR__.'/../vendor/autoload.php';

use Illuminate\Support\{Arr, Collection};
use OliverDaviesLtd\BuildConfigs\ConfigurationData;
use OliverDaviesLtd\BuildConfigs\DataTransferObject\TemplateFile;
use OliverDaviesLtd\BuildConfigs\Enum\{Language, WebServer};
use Silly\Application;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Serializer\Encoder\JsonEncoder;
use Symfony\Component\Serializer\NameConverter\CamelCaseToSnakeCaseNameConverter;
use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
use Symfony\Component\Serializer\Serializer;
use Symfony\Component\Validator\{ConstraintViolationInterface, Validation};
use Symfony\Component\Yaml\Yaml;
use Twig\Environment;
use Twig\Loader\FilesystemLoader;

$app = new Application();

$app->command(
    'generate-build-file [-p|--project-name=] [-t|--type=]',
    function(
        string $projectName,
        string $type,
    ): void {
        $projectName = str_replace('.', '-', $projectName);

        // TODO: validate the project type.
        $output = <<<EOF
            name: $projectName
            type: $type
            EOF;

        file_put_contents('build.yaml', $output);
    }
)->descriptions('Generate a new build.yaml file.', [
    '--project-name' => 'The name of the project.',
    '--type' => 'The project type.',
]);;

$app->command(
    'run [-c|--config-file=] [-o|--output-dir=]',
    function (
        SymfonyStyle $io,
        string $configFile = 'build.yaml',
        string $outputDir = '.',
    ): void {
        $configurationData = array_merge(
            Yaml::parseFile(__DIR__ . '/../resources/build.defaults.yaml'),
            Yaml::parseFile($configFile),
        );

        // Convert the input to a configuration data object.
        $normalizer = new ObjectNormalizer(null, new CamelCaseToSnakeCaseNameConverter());
        $serializer = new Serializer([$normalizer], [new JsonEncoder()]);
        $configurationDataObject = $serializer->deserialize(json_encode($configurationData), ConfigurationData::class, 'json');

        $validator = Validation::createValidatorBuilder()->enableAnnotationMapping()->getValidator();
        $violations = $validator->validate($configurationDataObject);

        if (0 < $violations->count()) {
            $io->error('Configuration is invalid.');

            $io->listing(
                collect($violations)
                    ->map(fn (ConstraintViolationInterface $v) => "{$v->getPropertyPath()} - {$v->getMessage()}")
                    ->toArray()
            );

            return;
        }

        if (isset($configurationData['docker-compose'])) {
            $configurationData['dockerCompose'] = $configurationData['docker-compose'];
            $configurationData['docker-compose'] = null;
        }

        $configurationData['managedText'] = 'Do not edit this file. It is automatically generated by \'build-configs\'.';

        $filesToGenerate = getFiles(configurationData: $configurationData);

        $io->info("Building configuration for {$configurationData['name']}.");

        $io->write('Generated files:');
        $io->listing(getListOfFiles(filesToGenerate: $filesToGenerate)->toArray());

        generateFiles(
            configurationData: $configurationData,
            filesToGenerate: $filesToGenerate,
            outputDir: $outputDir,
        );
    }
)->descriptions('Generate project-specific configuration files.', [
    '--config-file' => 'The path to the project\'s build.yaml file',
    '--output-dir' => 'The directory to create files in',
]);

$app->run();

/**
 * @param array<string, string> $configurationData
 * @param Collection<int, TemplateFile> $filesToGenerate
 */
function generateFiles(
    Collection $filesToGenerate,
    string $outputDir,
    array $configurationData,
): void
{
    $filesystem = new Filesystem();
    $twig = new Environment(new FilesystemLoader([__DIR__ . '/../templates']));

    $filesToGenerate->each(function(TemplateFile $templateFile) use ($configurationData, $filesystem, $outputDir, $twig): void {
        if ($templateFile->path !== null) {
            if (!$filesystem->exists($templateFile->path)) {
                $filesystem->mkdir("{$outputDir}/{$templateFile->path}");
            }
        }

        $sourceFile = "{$templateFile->data}.twig";
        $outputFile = collect([
            $outputDir,
            $templateFile->path,
            $templateFile->name,
        ])->filter()->implode('/');

        $filesystem->dumpFile($outputFile, $twig->render($sourceFile, $configurationData));
    });

    // If the Docker entrypoint file is generated, ensure it is executable.
    if ($filesystem->exists("{$outputDir}/tools/docker/images/php/root/usr/local/bin/docker-entrypoint-php")) {
        $filesystem->chmod("{$outputDir}/tools/docker/images/php/root/usr/local/bin/docker-entrypoint-php", 0755);
    }
}

function getFiles(array $configurationData): Collection
{
    /** @var Collection<int, TemplateFile> */
    $filesToGenerate = collect([
        new TemplateFile(data: 'common/.dockerignore', name: '.dockerignore'),
        new TemplateFile(data: 'common/.hadolint.yaml', name: '.hadolint.yaml'),
        new TemplateFile(data: 'env.example', name: '.env.example'),
    ]);

    $extraDatabases = Arr::get($configurationData, 'database.extra_databases', []);
    if (count($extraDatabases) > 0) {
        $filesToGenerate[] = new TemplateFile(
            data: 'extra-databases.sql',
            name: 'extra-databases.sql',
            path: 'tools/docker/images/database/root/docker-entrypoint-initdb.d',
        );
    }

    if (false !== Arr::get($configurationData, "justfile", true)) {
        $filesToGenerate[] = new TemplateFile(data: 'justfile', name: 'justfile');
    }

    if (isset($configurationData['dockerCompose']) && $configurationData['dockerCompose'] !== null) {
        $filesToGenerate[] = new TemplateFile(data: 'docker-compose.yaml', name: 'docker-compose.yaml');
    }

    if (isPhp(Arr::get($configurationData, 'language'))) {
        $filesToGenerate[] = new TemplateFile(data: 'php/Dockerfile', name: 'Dockerfile');
        $filesToGenerate[] = new TemplateFile(data: 'php/phpcs.xml', name: 'phpcs.xml.dist');
        $filesToGenerate[] = new TemplateFile(data: 'php/phpstan.neon', name: 'phpstan.neon.dist');
        $filesToGenerate[] = new TemplateFile(data: 'php/phpunit.xml', name: 'phpunit.xml.dist');
        $filesToGenerate[] = new TemplateFile(
            data: 'php/docker-entrypoint-php',
            name: 'docker-entrypoint-php',
            path: 'tools/docker/images/php/root/usr/local/bin',
        );
    }

    if (isNode(Arr::get($configurationData, 'language'))) {
        $filesToGenerate[] = new TemplateFile(data: 'node/.yarnrc', name: '.yarnrc');
        $filesToGenerate[] = new TemplateFile(data: 'node/Dockerfile', name: 'Dockerfile');
    }

    if (isCaddy(Arr::get($configurationData, 'web.type'))) {
        $filesToGenerate[] = new TemplateFile(
            data: 'web/caddy/Caddyfile',
            name: 'Caddyfile',
            path: 'tools/docker/images/web/root/etc/caddy',
        );
    }

    if (isNginx(Arr::get($configurationData, 'web.type'))) {
        $filesToGenerate[] = new TemplateFile(
            data: 'web/nginx/default.conf',
            name: 'default.conf',
            path: 'tools/docker/images/web/root/etc/nginx/conf.d',
        );
    }

    if ('drupal-project' === Arr::get($configurationData, 'type')) {
        // Add a Drupal version of phpunit.xml.dist.
        $filesToGenerate[] = new TemplateFile(data: 'drupal-project/phpunit.xml.dist', name: 'phpunit.xml.dist');
    }

    return $filesToGenerate;
}

function getListOfFiles(Collection $filesToGenerate): Collection
{
    return $filesToGenerate
        ->map(fn (TemplateFile $templateFile): string =>
            collect([$templateFile->path, $templateFile->name])->filter()->implode('/'))
        ->unique()
        ->sort();
}

function isCaddy(?string $webServer): bool
{
    if (is_null($webServer)) {
        return false;
    }

    return strtoupper($webServer) === WebServer::CADDY->name;
}

function isNginx(?string $webServer): bool
{
    if (is_null($webServer)) {
        return false;
    }

    return strtoupper($webServer) === WebServer::NGINX->name;
}

function isNode(?string $language): bool
{
    if (is_null($language)) {
        return false;
    }

    return strtoupper($language) === Language::NODE->name;
}

function isPhp(?string $language): bool
{
    if (is_null($language)) {
        return false;
    }

    return strtoupper($language) === Language::PHP->name;
}
